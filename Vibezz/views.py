from django.http import JsonResponse
import json
import requests
import hashlib
import time
from django.shortcuts import render
from django.conf import settings
from django.utils.html import escape
from django.core.cache import cache
from django.utils import timezone
import re
from django.views.decorators.csrf import csrf_exempt
from .models import PoemGeneration

def home(request):
    """Render the main page"""
    return render(request, 'index.html')

def check_rate_limit(request):
    """
    Rate limiting by IP address
    Allows 5 requests per minute per IP
    """
    client_ip = request.META.get('REMOTE_ADDR', 'unknown')
    if client_ip == 'unknown':
        client_ip = request.META.get('HTTP_X_FORWARDED_FOR', 'unknown')
    
    # Create a hash of the IP for cache key
    cache_key = f'rate_limit_{hashlib.md5(client_ip.encode()).hexdigest()}'
    
    # Get current request count for this IP
    current_requests = cache.get(cache_key, 0)
    
    # Check if limit exceeded
    if current_requests >= 5:  # 5 requests per minute
        return False
    
    # Increment request count with 60 second expiry
    cache.set(cache_key, current_requests + 1, 60)
    return True

@csrf_exempt
def get_vibe(request):
    """
    Get Vibe - Generates a poem using Gemini API
    Params: theme, mood, for
    """
    if request.method != 'POST':
        return JsonResponse({'error': 'Invalid request method'}, status=405)
    
    # Check rate limit
    if not check_rate_limit(request):
        return JsonResponse({
            'error': 'Rate limit exceeded. Please wait a moment before trying again.',
            'retry_after': 60
        }, status=429)
    
    try:
        data = json.loads(request.body)

        theme = escape(data.get('theme', '').strip())
        mood = escape(data.get('mood', '').strip())
        to = escape(data.get('for', '').strip())

        if not all([theme, mood, to]):
            return JsonResponse({'error': 'Missing required parameters: theme, mood, for'}, status=400)
        
        if len(theme) > 30 or len(mood) > 30 or len(to) > 20:
            return JsonResponse({'error': 'Input too long'}, status=400)
        
        # Validate against malicious patterns
        if not re.match(r'^[a-zA-Z0-9\s\-\'.,!?]+$', theme + mood + to):
            return JsonResponse({'error': 'Invalid characters in input'}, status=400)
        
        prompt = f'Generate a creative, strictly 4 line poem about {theme}, {mood} mood, for {to}.'

        poem = call_gemini_api(prompt)

        poem_record = PoemGeneration.objects.create(
            theme=theme,
            mood=mood,
            recipient=to,
            prompt=prompt,
            generated_poem=poem
        )
        
        return JsonResponse({
            'success': True,
            'poem': poem,
            'poem_id': poem_record.id,
            'parameters': {
                'theme': theme,
                'mood': mood,
                'for': to
            }
        })
    
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON data'}, status=400)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

def call_gemini_api(prompt):
    try:
        url = f'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={settings.GEMINI_API_KEY}'
        
        payload = {
            "contents": [{
                "parts": [{
                    "text": prompt
                }]
            }]
        }

        headers = {
            'Content-Type': 'application/json'
        }

        response = requests.post(url, headers=headers, json=payload, timeout=30)
        if response.status_code == 401:
            raise Exception("Invalid API key")
        elif response.status_code == 403:
            raise Exception("API key access denied")
        elif response.status_code == 429:
            raise Exception("Rate limit exceeded")
        elif response.status_code == 503:
            raise Exception("Service temporarily unavailable")
        
        response.raise_for_status()

        result = response.json()

        # Extract text from Gemini response format
        # if 'candidates' in result and len(result['candidates']) > 0:
        #     return result['candidates'][0]['content']['parts'][0]['text']
        # else:
        #     raise Exception("No content generated by Gemini API")
        if 'candidates' in result and len(result['candidates']) > 0:
            candidate = result['candidates'][0]
            if 'content' in candidate and 'parts' in candidate['content']:
                parts = candidate['content']['parts']
                if parts and 'text' in parts[0]:
                    return parts[0]['text'].strip()
        
        raise Exception("No content generated by Gemini API")
            
    except requests.exceptions.RequestException as e:
        raise Exception(f"API request failed: {str(e)}")
    except KeyError as e:
        raise Exception(f"Unexpected API response format: {str(e)}")
    except Exception as e:
        raise Exception(f"Gemini API error: {str(e)}")